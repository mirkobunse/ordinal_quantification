<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ordinal_quantification.decomposition package &mdash; ordinal_quantification v0.0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            ordinal_quantification
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="developer-guide.html">Developer guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ordinal_quantification</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">ordinal_quantification.decomposition package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/ordinal_quantification.decomposition.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="ordinal-quantification-decomposition-package">
<h1>ordinal_quantification.decomposition package<a class="headerlink" href="#ordinal-quantification-decomposition-package" title="Permalink to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
</section>
<section id="module-ordinal_quantification.decomposition.multiclass">
<span id="ordinal-quantification-decomposition-multiclass-module"></span><h2>ordinal_quantification.decomposition.multiclass module<a class="headerlink" href="#module-ordinal_quantification.decomposition.multiclass" title="Permalink to this heading"></a></h2>
<p>Generic quantifiers based on multiclass decompositions</p>
<dl class="py class">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ordinal_quantification.decomposition.multiclass.</span></span><span class="sig-name descname"><span class="pre">OneVsRestQuantifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quantifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_train</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="ordinal_quantification.html#ordinal_quantification.base.UsingClassifiers" title="ordinal_quantification.base.UsingClassifiers"><code class="xref py py-class docutils literal notranslate"><span class="pre">UsingClassifiers</span></code></a></p>
<p>Implements a One Vs Rest Multiclass Quantifier given any base quantifier</p>
<p>Trains one quantifier per class that predicts the prevalence on such class. The aggregation strategy
just normalizes these prevalences to sum 1</p>
<p>The class works both with quantifiers that require classifiers or not. In the former case, the estimator
used for the training distribution and the testing distribution must be a OneVsRestQuantifier</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>quantifier</strong> (<em>quantifier object</em>) – The base quantifier used to build the One versus Rest decomposition. Any quantifier can be used</p></li>
<li><p><strong>estimator_train</strong> (<em>estimator object</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and one of <cite>predict</cite> or <cite>predict_proba</cite>. It is used to classify
the examples of the training set and to obtain their distribution when the base quantifier is an
instance of the class UsingClassifiers. Notice that some quantifiers of this kind, namely CC and PCC,
do not require an estimator for the training distribution</p></li>
<li><p><strong>estimator_test</strong> (<em>estimator object</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and one of <cite>predict</cite> or <cite>predict_proba</cite>. It is used to classify
the examples of the testing bag and to obtain their distribution when the base quantifier is an
instance of the class UsingClassifiers</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=0</em><em>)</em>) – The verbosity level. The default value, zero, means silent mode</p></li>
<li><p><strong>same</strong> (<em>For some experiments both estimators could be the</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.quantifier">
<span class="sig-name descname"><span class="pre">quantifier</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.quantifier" title="Permalink to this definition"></a></dt>
<dd><p>The base quantifier used to build the One versus Rest decomposition</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>quantifier object</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.estimator_train">
<span class="sig-name descname"><span class="pre">estimator_train</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.estimator_train" title="Permalink to this definition"></a></dt>
<dd><p>Estimator used to classify the examples of the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.estimator_test">
<span class="sig-name descname"><span class="pre">estimator_test</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.estimator_test" title="Permalink to this definition"></a></dt>
<dd><p>Estimator used to classify the examples of the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.predictions_train_">
<span class="sig-name descname"><span class="pre">predictions_train_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.predictions_train_" title="Permalink to this definition"></a></dt>
<dd><p>Predictions of the examples in the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_examples, n_classes) (probabilistic)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.predictions_test_">
<span class="sig-name descname"><span class="pre">predictions_test_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.predictions_test_" title="Permalink to this definition"></a></dt>
<dd><p>Predictions of the examples in the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_examples, n_classes) (probabilistic)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.needs_predictions_train">
<span class="sig-name descname"><span class="pre">needs_predictions_train</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.needs_predictions_train" title="Permalink to this definition"></a></dt>
<dd><p>True if the base quantifier needs to estimate the training distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, (default=True)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.probabilistic_predictions">
<span class="sig-name descname"><span class="pre">probabilistic_predictions</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.probabilistic_predictions" title="Permalink to this definition"></a></dt>
<dd><p>Not used</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.quantifiers_">
<span class="sig-name descname"><span class="pre">quantifiers_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.quantifiers_" title="Permalink to this definition"></a></dt>
<dd><p>List of quantifiers, one for each class</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.classes_">
<span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.classes_" title="Permalink to this definition"></a></dt>
<dd><p>Class labels</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.y_ext_">
<span class="sig-name descname"><span class="pre">y_ext_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.y_ext_" title="Permalink to this definition"></a></dt>
<dd><p>Repmat of true labels of the training set. When CV_estimator is used with averaged_predictions=False,
<a href="#id3"><span class="problematic" id="id4">predictions_train_</span></a> will have a larger dimension (factor=n_repetitions * n_folds of the underlying
CV_estimator) than y. In other cases, <a href="#id5"><span class="problematic" id="id6">y_ext_</span></a> == y.
<a href="#id7"><span class="problematic" id="id8">y_ext_</span></a> must be used in <cite>fit</cite>/<cite>predict</cite> methods whenever the true labels of the training set are needed,
instead of y</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape(len(<a href="#id9"><span class="problematic" id="id10">predictions_train_</span></a>), )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.verbose" title="Permalink to this definition"></a></dt>
<dd><p>The verbosity level</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_train</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fits all the quanfifiers of a OneVsRest decomposition</p>
<p>First, the method fits the estimators (estimator_train and estimator_test) (if needed) using
the <cite>fit</cite> method of its superclass</p>
<p>Then, it creates (using <cite>deepcopy</cite>) the set on <a href="#id11"><span class="problematic" id="id12">quantifiers_</span></a>, one per class, and fit them</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>)</em>) – True classes</p></li>
<li><p><strong>predictions_train</strong> (<em>ndarray</em><em>, </em><em>optional</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_classes</em><em>) </em><em>(</em><em>probs</em><em>)</em>) – Predictions of the examples in the training set</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When estimator_train or estimator_test are not instances of OneVsRestClassifier</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.decomposition.multiclass.OneVsRestQuantifier.predict" title="Permalink to this definition"></a></dt>
<dd><p>Aggregates the prevalences of the <a href="#id13"><span class="problematic" id="id14">quantifiers_</span></a> to compute the final prediction</p>
<p>Just one aggregation strategy is implemented. It normalizes the prevalences given by each quantifier
to sum 1</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p></li>
<li><p><strong>predictions_test</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_classes</em><em>) </em><em>(</em><em>default=None</em><em>)</em>) – Predictions for the testing bag</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-ordinal_quantification.decomposition.ordinal">
<span id="ordinal-quantification-decomposition-ordinal-module"></span><h2>ordinal_quantification.decomposition.ordinal module<a class="headerlink" href="#module-ordinal_quantification.decomposition.ordinal" title="Permalink to this heading"></a></h2>
<p>Generic quantifier based on Frank and Hall decomposition</p>
<dl class="py class">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ordinal_quantification.decomposition.ordinal.</span></span><span class="sig-name descname"><span class="pre">FrankAndHallQuantifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quantifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_train</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="ordinal_quantification.html#ordinal_quantification.base.UsingClassifiers" title="ordinal_quantification.base.UsingClassifiers"><code class="xref py py-class docutils literal notranslate"><span class="pre">UsingClassifiers</span></code></a></p>
<p>Implements a Frank and Hall Ordinal Quantifier given any base quantifier</p>
<p>Trains one quantifier per each model of the Frank and Hall (FH) decocompositon. For instance, in a ordinal
classification problem with classes ranging from 1-star to 5-star, FHQuantifier trains 4 quantifiers:
1 vs 2-3-4-5, 1-2 vs 3-4-5, 1-2-3 vs 4-5, 1-2-3-4 vs 5 and combines their predictions. The positive class
correspond to the left group of each quantifier ({1}, {1,2}, and so on)</p>
<p>The class works both with quantifiers that require classifiers or not. In the former case, the estimator
used for the training distribution and the testing distribution must be a FrankAndHallClassifier</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>quantifier</strong> (<em>quantifier object</em>) – The base quantifier used to build the FH decomposition. Any quantifier can be used</p></li>
<li><p><strong>estimator_train</strong> (<em>estimator object</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and one of <cite>predict</cite> or <cite>predict_proba</cite>. It is used to classify
the examples of the training set and to obtain their distribution when the base quantifier is an
instance of the class UsingClassifiers. Notice that some quantifiers of this kind, namely CC and PCC,
do not require an estimator for the training distribution</p></li>
<li><p><strong>estimator_test</strong> (<em>estimator object</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and one of <cite>predict</cite> or <cite>predict_proba</cite>. It is used to classify
the examples of the testing bag and to obtain their distribution when the base quantifier is an
instance of the class UsingClassifiers</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=0</em><em>)</em>) – The verbosity level. The default value, zero, means silent mode</p></li>
<li><p><strong>same</strong> (<em>For some experiments both estimators could be the</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.quantifier">
<span class="sig-name descname"><span class="pre">quantifier</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.quantifier" title="Permalink to this definition"></a></dt>
<dd><p>The base quantifier used to build the FH decomposition</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>quantifier object</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.estimator_train">
<span class="sig-name descname"><span class="pre">estimator_train</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.estimator_train" title="Permalink to this definition"></a></dt>
<dd><p>Estimator used to classify the examples of the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.estimator_test">
<span class="sig-name descname"><span class="pre">estimator_test</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.estimator_test" title="Permalink to this definition"></a></dt>
<dd><p>Estimator used to classify the examples of the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.predictions_train_">
<span class="sig-name descname"><span class="pre">predictions_train_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.predictions_train_" title="Permalink to this definition"></a></dt>
<dd><p>Predictions of the examples in the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_examples, n_classes-1) (probabilistic)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.predictions_test_">
<span class="sig-name descname"><span class="pre">predictions_test_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.predictions_test_" title="Permalink to this definition"></a></dt>
<dd><p>Predictions of the examples in the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_examples, n_classes-1) (probabilistic)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.needs_predictions_train">
<span class="sig-name descname"><span class="pre">needs_predictions_train</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.needs_predictions_train" title="Permalink to this definition"></a></dt>
<dd><p>True if the base quantifier needs to estimate the training distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, (default=True)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.probabilistic_predictions">
<span class="sig-name descname"><span class="pre">probabilistic_predictions</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.probabilistic_predictions" title="Permalink to this definition"></a></dt>
<dd><p>Not used</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.quantifiers_">
<span class="sig-name descname"><span class="pre">quantifiers_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.quantifiers_" title="Permalink to this definition"></a></dt>
<dd><p>List of quantifiers, one for each model of a FH decomposition. The number is equal to n_classes - 1</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes-1, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.classes_">
<span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.classes_" title="Permalink to this definition"></a></dt>
<dd><p>Class labels</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.y_ext_">
<span class="sig-name descname"><span class="pre">y_ext_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.y_ext_" title="Permalink to this definition"></a></dt>
<dd><p>Repmat of true labels of the training set. When CV_estimator is used with averaged_predictions=False,
<a href="#id15"><span class="problematic" id="id16">predictions_train_</span></a> will have a larger dimension (factor=n_repetitions * n_folds of the underlying
CV_estimator) than y. In other cases, <a href="#id17"><span class="problematic" id="id18">y_ext_</span></a> == y.
<a href="#id19"><span class="problematic" id="id20">y_ext_</span></a> must be used in <cite>fit</cite>/<cite>predict</cite> methods whenever the true labels of the training set are needed,
instead of y</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape(len(<a href="#id21"><span class="problematic" id="id22">predictions_train_</span></a>), )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.verbose" title="Permalink to this definition"></a></dt>
<dd><p>The verbosity level</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_train</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fits all the quanfifiers of a FH decomposition</p>
<p>First, the method fits the estimators (estimator_train and estimator_test) (if needed) using
the <cite>fit</cite> method of its superclass</p>
<p>Then, it creates (using <cite>deepcopy</cite>) the set on <a href="#id23"><span class="problematic" id="id24">quantifiers_</span></a> (n_classes-1 quantifiers) and fit them</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>)</em>) – True classes</p></li>
<li><p><strong>predictions_train</strong> (<em>ndarray</em><em>, </em><em>optional</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_classes-1</em><em>) </em><em>(</em><em>probs</em><em>)</em>) – Predictions of the examples in the training set</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When estimator_train or estimator_test are not instances of OneVsRestClassifier</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.decomposition.ordinal.FrankAndHallQuantifier.predict" title="Permalink to this definition"></a></dt>
<dd><p>Aggregates the prevalences of the <a href="#id25"><span class="problematic" id="id26">quantifiers_</span></a> to compute the final prediction</p>
<p>In this kind of decomposition strategy it is important to ensure that the aggregated consecutive
prevalencences do not decrease:</p>
<p class="rubric">Example</p>
<p>Quantifier 1 vs 2-3-4   Prevalence({1}) = 0.3
Quantifier 1-2 vs 3-4   Prevalence({1,2}) = 0.2
Quantifier 1-2-3 vs 4   Prevalence({1,2,3}) = 0.6</p>
<p>This is inconsistent. Following (Destercke, Yang, 2014) the method computes the upper (adjusting from
left to right) and the lower (from right to left) cumulative prevalences. These sets of values are
monotonically increasing (from left to right) and monotonically decreasing (from right to left),
respectively. The average value is assigned to each group and the prevalence for each class is computed as:</p>
<blockquote>
<div><p>Prevalence({y_k}) = Prevalence({y_1,…,y_k}) - Prevalence({y_1,…,y_k-1})</p>
</div></blockquote>
<p class="rubric">Example</p>
<p>{1}   {1-2}  {1-2-3}</p>
<p>0.3   0.3    0.6    Upper cumulative prevalences (adjusting from left to right)</p>
<section id="lower-cumulative-prevalences-adjusting-from-right-to-left">
<h3>0.2   0.2    0.6    Lower cumulative prevalences (adjusting from right to left)<a class="headerlink" href="#lower-cumulative-prevalences-adjusting-from-right-to-left" title="Permalink to this heading"></a></h3>
<p>0.25  0.25   0.6    Averaged prevalences</p>
<p>Prevalence({1}) = 0.25
Prevalence({2}) = Prevalence({1,2}) - Prevalence({1}) = 0.25 - 0 .25 = 0
Prevalence({3}) = Prevalence({1,2,3}} - Prevalence({1,2}) = 0.6 - 0.25 = 0.35</p>
<p>The last class is computed as 1 - the sum of prevalences for the rest of classes</p>
<p>Prevalence({4}) = 1 - Prevalence({1,2,3}} = 1 - 0.6 = 0.4</p>
<dl class="field-list simple">
<dt class="field-odd">param X<span class="colon">:</span></dt>
<dd class="field-odd"><p>Data</p>
</dd>
<dt class="field-even">type X<span class="colon">:</span></dt>
<dd class="field-even"><p>(sparse) array-like, shape (n_examples, n_features)</p>
</dd>
<dt class="field-odd">param predictions_test<span class="colon">:</span></dt>
<dd class="field-odd"><p>Predictions for the testing bag</p>
</dd>
<dt class="field-even">type predictions_test<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray, shape (n_examples, n_classes) (default=None)</p>
</dd>
<dt class="field-odd">returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prevalences</strong> – Contains the predicted prevalence for each class</p>
</dd>
<dt class="field-even">rtype<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray, shape(n_classes, )</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>Destercke, S., &amp; Yang, G. (2014, September). Cautious ordinal classification by binary decomposition.
In Joint European Conference on Machine Learning and Knowledge Discovery in Databases (pp. 323-337).</p>
</section>
</dd></dl>

</dd></dl>

</section>
<section id="module-ordinal_quantification.decomposition.utils">
<span id="ordinal-quantification-decomposition-utils-module"></span><h2>ordinal_quantification.decomposition.utils module<a class="headerlink" href="#module-ordinal_quantification.decomposition.utils" title="Permalink to this heading"></a></h2>
<p>Util functions used for building quantifiers based on decomposition</p>
<dl class="py function">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.utils.check_and_correct_prevalences_asc">
<span class="sig-prename descclassname"><span class="pre">ordinal_quantification.decomposition.utils.</span></span><span class="sig-name descname"><span class="pre">check_and_correct_prevalences_asc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prevalences</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.decomposition.utils.check_and_correct_prevalences_asc" title="Permalink to this definition"></a></dt>
<dd><p>This function checks and corrects the prevalences of a quantifier based on the Frank and Hall decomposition
that are inconsistent. It is used by FrankAndHallQuantifier.</p>
<p>To obtain consistent prevalences, we need to ensure that the consecutive probabilities do not decrease.</p>
<p class="rubric">Example</p>
<p>Quantifier 1 vs 2-3-4   Prevalence({1}) = 0.3
Quantifier 1-2 vs 3-4   Prevalence({1,2}) = 0.2
Quantifier 1-2-3 vs 4   Prevalence({1,2,3}) = 0.6</p>
<p>This is inconsistent. Following (Destercke, Yang, 2014) the method computes the upper (adjusting from
left to right) and the lower (from right to left) cumulative prevalences. These sets of values are
monotonically increasing (from left to right) and monotonically decreasing (from right to left),
respectively. The average value is assigned to each group</p>
<p class="rubric">Example</p>
<p>{1}   {1-2}  {1-2-3}</p>
<p>0.3   0.3    0.6    Upper cumulative prevalences (adjusting from left to right)</p>
<section id="id1">
<h3>0.2   0.2    0.6    Lower cumulative prevalences (adjusting from right to left)<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h3>
<p>0.25  0.25   0.6    Averaged prevalences</p>
<dl class="field-list simple">
<dt class="field-odd">param prevalences<span class="colon">:</span></dt>
<dd class="field-odd"><p>The prevalences of the binary quantifiers of a FrankAndHallQuantifier for a single dataset</p>
</dd>
<dt class="field-even">type prevalences<span class="colon">:</span></dt>
<dd class="field-even"><p>array, shape(n_classes-1, )</p>
</dd>
<dt class="field-odd">returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prevalences_ok</strong> – The corrected prevalences ensuring that do not decrease (from left to right)</p>
</dd>
<dt class="field-even">rtype<span class="colon">:</span></dt>
<dd class="field-even"><p>array, shape(n_classes-1)</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>Sébastien Destercke, Gen Yang. Cautious Ordinal Classification by Binary Decomposition.
Machine Learning and Knowledge Discovery in Databases - European Conference ECML/PKDD,
Sep 2014, Nancy, France. pp.323 - 337, 2014,</p>
</section>
</dd></dl>

</section>
<section id="module-ordinal_quantification.decomposition">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-ordinal_quantification.decomposition" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.FrankAndHallQuantifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ordinal_quantification.decomposition.</span></span><span class="sig-name descname"><span class="pre">FrankAndHallQuantifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quantifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_train</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.decomposition.FrankAndHallQuantifier" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="ordinal_quantification.html#ordinal_quantification.base.UsingClassifiers" title="ordinal_quantification.base.UsingClassifiers"><code class="xref py py-class docutils literal notranslate"><span class="pre">UsingClassifiers</span></code></a></p>
<p>Implements a Frank and Hall Ordinal Quantifier given any base quantifier</p>
<p>Trains one quantifier per each model of the Frank and Hall (FH) decocompositon. For instance, in a ordinal
classification problem with classes ranging from 1-star to 5-star, FHQuantifier trains 4 quantifiers:
1 vs 2-3-4-5, 1-2 vs 3-4-5, 1-2-3 vs 4-5, 1-2-3-4 vs 5 and combines their predictions. The positive class
correspond to the left group of each quantifier ({1}, {1,2}, and so on)</p>
<p>The class works both with quantifiers that require classifiers or not. In the former case, the estimator
used for the training distribution and the testing distribution must be a FrankAndHallClassifier</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>quantifier</strong> (<em>quantifier object</em>) – The base quantifier used to build the FH decomposition. Any quantifier can be used</p></li>
<li><p><strong>estimator_train</strong> (<em>estimator object</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and one of <cite>predict</cite> or <cite>predict_proba</cite>. It is used to classify
the examples of the training set and to obtain their distribution when the base quantifier is an
instance of the class UsingClassifiers. Notice that some quantifiers of this kind, namely CC and PCC,
do not require an estimator for the training distribution</p></li>
<li><p><strong>estimator_test</strong> (<em>estimator object</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and one of <cite>predict</cite> or <cite>predict_proba</cite>. It is used to classify
the examples of the testing bag and to obtain their distribution when the base quantifier is an
instance of the class UsingClassifiers</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=0</em><em>)</em>) – The verbosity level. The default value, zero, means silent mode</p></li>
<li><p><strong>same</strong> (<em>For some experiments both estimators could be the</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.FrankAndHallQuantifier.quantifier">
<span class="sig-name descname"><span class="pre">quantifier</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.FrankAndHallQuantifier.quantifier" title="Permalink to this definition"></a></dt>
<dd><p>The base quantifier used to build the FH decomposition</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>quantifier object</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.FrankAndHallQuantifier.estimator_train">
<span class="sig-name descname"><span class="pre">estimator_train</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.FrankAndHallQuantifier.estimator_train" title="Permalink to this definition"></a></dt>
<dd><p>Estimator used to classify the examples of the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.FrankAndHallQuantifier.estimator_test">
<span class="sig-name descname"><span class="pre">estimator_test</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.FrankAndHallQuantifier.estimator_test" title="Permalink to this definition"></a></dt>
<dd><p>Estimator used to classify the examples of the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.FrankAndHallQuantifier.predictions_train_">
<span class="sig-name descname"><span class="pre">predictions_train_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.FrankAndHallQuantifier.predictions_train_" title="Permalink to this definition"></a></dt>
<dd><p>Predictions of the examples in the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_examples, n_classes-1) (probabilistic)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.FrankAndHallQuantifier.predictions_test_">
<span class="sig-name descname"><span class="pre">predictions_test_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.FrankAndHallQuantifier.predictions_test_" title="Permalink to this definition"></a></dt>
<dd><p>Predictions of the examples in the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_examples, n_classes-1) (probabilistic)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.FrankAndHallQuantifier.needs_predictions_train">
<span class="sig-name descname"><span class="pre">needs_predictions_train</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.FrankAndHallQuantifier.needs_predictions_train" title="Permalink to this definition"></a></dt>
<dd><p>True if the base quantifier needs to estimate the training distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, (default=True)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.FrankAndHallQuantifier.probabilistic_predictions">
<span class="sig-name descname"><span class="pre">probabilistic_predictions</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.FrankAndHallQuantifier.probabilistic_predictions" title="Permalink to this definition"></a></dt>
<dd><p>Not used</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.FrankAndHallQuantifier.quantifiers_">
<span class="sig-name descname"><span class="pre">quantifiers_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.FrankAndHallQuantifier.quantifiers_" title="Permalink to this definition"></a></dt>
<dd><p>List of quantifiers, one for each model of a FH decomposition. The number is equal to n_classes - 1</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes-1, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.FrankAndHallQuantifier.classes_">
<span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.FrankAndHallQuantifier.classes_" title="Permalink to this definition"></a></dt>
<dd><p>Class labels</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.FrankAndHallQuantifier.y_ext_">
<span class="sig-name descname"><span class="pre">y_ext_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.FrankAndHallQuantifier.y_ext_" title="Permalink to this definition"></a></dt>
<dd><p>Repmat of true labels of the training set. When CV_estimator is used with averaged_predictions=False,
<a href="#id27"><span class="problematic" id="id28">predictions_train_</span></a> will have a larger dimension (factor=n_repetitions * n_folds of the underlying
CV_estimator) than y. In other cases, <a href="#id29"><span class="problematic" id="id30">y_ext_</span></a> == y.
<a href="#id31"><span class="problematic" id="id32">y_ext_</span></a> must be used in <cite>fit</cite>/<cite>predict</cite> methods whenever the true labels of the training set are needed,
instead of y</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape(len(<a href="#id33"><span class="problematic" id="id34">predictions_train_</span></a>), )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.FrankAndHallQuantifier.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.FrankAndHallQuantifier.verbose" title="Permalink to this definition"></a></dt>
<dd><p>The verbosity level</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.FrankAndHallQuantifier.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_train</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.decomposition.FrankAndHallQuantifier.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fits all the quanfifiers of a FH decomposition</p>
<p>First, the method fits the estimators (estimator_train and estimator_test) (if needed) using
the <cite>fit</cite> method of its superclass</p>
<p>Then, it creates (using <cite>deepcopy</cite>) the set on <a href="#id35"><span class="problematic" id="id36">quantifiers_</span></a> (n_classes-1 quantifiers) and fit them</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>)</em>) – True classes</p></li>
<li><p><strong>predictions_train</strong> (<em>ndarray</em><em>, </em><em>optional</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_classes-1</em><em>) </em><em>(</em><em>probs</em><em>)</em>) – Predictions of the examples in the training set</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When estimator_train or estimator_test are not instances of OneVsRestClassifier</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.FrankAndHallQuantifier.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.decomposition.FrankAndHallQuantifier.predict" title="Permalink to this definition"></a></dt>
<dd><p>Aggregates the prevalences of the <a href="#id37"><span class="problematic" id="id38">quantifiers_</span></a> to compute the final prediction</p>
<p>In this kind of decomposition strategy it is important to ensure that the aggregated consecutive
prevalencences do not decrease:</p>
<p class="rubric">Example</p>
<p>Quantifier 1 vs 2-3-4   Prevalence({1}) = 0.3
Quantifier 1-2 vs 3-4   Prevalence({1,2}) = 0.2
Quantifier 1-2-3 vs 4   Prevalence({1,2,3}) = 0.6</p>
<p>This is inconsistent. Following (Destercke, Yang, 2014) the method computes the upper (adjusting from
left to right) and the lower (from right to left) cumulative prevalences. These sets of values are
monotonically increasing (from left to right) and monotonically decreasing (from right to left),
respectively. The average value is assigned to each group and the prevalence for each class is computed as:</p>
<blockquote>
<div><p>Prevalence({y_k}) = Prevalence({y_1,…,y_k}) - Prevalence({y_1,…,y_k-1})</p>
</div></blockquote>
<p class="rubric">Example</p>
<p>{1}   {1-2}  {1-2-3}</p>
<p>0.3   0.3    0.6    Upper cumulative prevalences (adjusting from left to right)</p>
<section id="id2">
<h3>0.2   0.2    0.6    Lower cumulative prevalences (adjusting from right to left)<a class="headerlink" href="#id2" title="Permalink to this heading"></a></h3>
<p>0.25  0.25   0.6    Averaged prevalences</p>
<p>Prevalence({1}) = 0.25
Prevalence({2}) = Prevalence({1,2}) - Prevalence({1}) = 0.25 - 0 .25 = 0
Prevalence({3}) = Prevalence({1,2,3}} - Prevalence({1,2}) = 0.6 - 0.25 = 0.35</p>
<p>The last class is computed as 1 - the sum of prevalences for the rest of classes</p>
<p>Prevalence({4}) = 1 - Prevalence({1,2,3}} = 1 - 0.6 = 0.4</p>
<dl class="field-list simple">
<dt class="field-odd">param X<span class="colon">:</span></dt>
<dd class="field-odd"><p>Data</p>
</dd>
<dt class="field-even">type X<span class="colon">:</span></dt>
<dd class="field-even"><p>(sparse) array-like, shape (n_examples, n_features)</p>
</dd>
<dt class="field-odd">param predictions_test<span class="colon">:</span></dt>
<dd class="field-odd"><p>Predictions for the testing bag</p>
</dd>
<dt class="field-even">type predictions_test<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray, shape (n_examples, n_classes) (default=None)</p>
</dd>
<dt class="field-odd">returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prevalences</strong> – Contains the predicted prevalence for each class</p>
</dd>
<dt class="field-even">rtype<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray, shape(n_classes, )</p>
</dd>
</dl>
<p class="rubric">References</p>
<p>Destercke, S., &amp; Yang, G. (2014, September). Cautious ordinal classification by binary decomposition.
In Joint European Conference on Machine Learning and Knowledge Discovery in Databases (pp. 323-337).</p>
</section>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.OneVsRestQuantifier">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ordinal_quantification.decomposition.</span></span><span class="sig-name descname"><span class="pre">OneVsRestQuantifier</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quantifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_train</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.decomposition.OneVsRestQuantifier" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="ordinal_quantification.html#ordinal_quantification.base.UsingClassifiers" title="ordinal_quantification.base.UsingClassifiers"><code class="xref py py-class docutils literal notranslate"><span class="pre">UsingClassifiers</span></code></a></p>
<p>Implements a One Vs Rest Multiclass Quantifier given any base quantifier</p>
<p>Trains one quantifier per class that predicts the prevalence on such class. The aggregation strategy
just normalizes these prevalences to sum 1</p>
<p>The class works both with quantifiers that require classifiers or not. In the former case, the estimator
used for the training distribution and the testing distribution must be a OneVsRestQuantifier</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>quantifier</strong> (<em>quantifier object</em>) – The base quantifier used to build the One versus Rest decomposition. Any quantifier can be used</p></li>
<li><p><strong>estimator_train</strong> (<em>estimator object</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and one of <cite>predict</cite> or <cite>predict_proba</cite>. It is used to classify
the examples of the training set and to obtain their distribution when the base quantifier is an
instance of the class UsingClassifiers. Notice that some quantifiers of this kind, namely CC and PCC,
do not require an estimator for the training distribution</p></li>
<li><p><strong>estimator_test</strong> (<em>estimator object</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and one of <cite>predict</cite> or <cite>predict_proba</cite>. It is used to classify
the examples of the testing bag and to obtain their distribution when the base quantifier is an
instance of the class UsingClassifiers</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=0</em><em>)</em>) – The verbosity level. The default value, zero, means silent mode</p></li>
<li><p><strong>same</strong> (<em>For some experiments both estimators could be the</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.OneVsRestQuantifier.quantifier">
<span class="sig-name descname"><span class="pre">quantifier</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.OneVsRestQuantifier.quantifier" title="Permalink to this definition"></a></dt>
<dd><p>The base quantifier used to build the One versus Rest decomposition</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>quantifier object</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.OneVsRestQuantifier.estimator_train">
<span class="sig-name descname"><span class="pre">estimator_train</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.OneVsRestQuantifier.estimator_train" title="Permalink to this definition"></a></dt>
<dd><p>Estimator used to classify the examples of the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.OneVsRestQuantifier.estimator_test">
<span class="sig-name descname"><span class="pre">estimator_test</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.OneVsRestQuantifier.estimator_test" title="Permalink to this definition"></a></dt>
<dd><p>Estimator used to classify the examples of the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.OneVsRestQuantifier.predictions_train_">
<span class="sig-name descname"><span class="pre">predictions_train_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.OneVsRestQuantifier.predictions_train_" title="Permalink to this definition"></a></dt>
<dd><p>Predictions of the examples in the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_examples, n_classes) (probabilistic)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.OneVsRestQuantifier.predictions_test_">
<span class="sig-name descname"><span class="pre">predictions_test_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.OneVsRestQuantifier.predictions_test_" title="Permalink to this definition"></a></dt>
<dd><p>Predictions of the examples in the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_examples, n_classes) (probabilistic)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.OneVsRestQuantifier.needs_predictions_train">
<span class="sig-name descname"><span class="pre">needs_predictions_train</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.OneVsRestQuantifier.needs_predictions_train" title="Permalink to this definition"></a></dt>
<dd><p>True if the base quantifier needs to estimate the training distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, (default=True)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.OneVsRestQuantifier.probabilistic_predictions">
<span class="sig-name descname"><span class="pre">probabilistic_predictions</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.OneVsRestQuantifier.probabilistic_predictions" title="Permalink to this definition"></a></dt>
<dd><p>Not used</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.OneVsRestQuantifier.quantifiers_">
<span class="sig-name descname"><span class="pre">quantifiers_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.OneVsRestQuantifier.quantifiers_" title="Permalink to this definition"></a></dt>
<dd><p>List of quantifiers, one for each class</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.OneVsRestQuantifier.classes_">
<span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.OneVsRestQuantifier.classes_" title="Permalink to this definition"></a></dt>
<dd><p>Class labels</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.OneVsRestQuantifier.y_ext_">
<span class="sig-name descname"><span class="pre">y_ext_</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.OneVsRestQuantifier.y_ext_" title="Permalink to this definition"></a></dt>
<dd><p>Repmat of true labels of the training set. When CV_estimator is used with averaged_predictions=False,
<a href="#id39"><span class="problematic" id="id40">predictions_train_</span></a> will have a larger dimension (factor=n_repetitions * n_folds of the underlying
CV_estimator) than y. In other cases, <a href="#id41"><span class="problematic" id="id42">y_ext_</span></a> == y.
<a href="#id43"><span class="problematic" id="id44">y_ext_</span></a> must be used in <cite>fit</cite>/<cite>predict</cite> methods whenever the true labels of the training set are needed,
instead of y</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape(len(<a href="#id45"><span class="problematic" id="id46">predictions_train_</span></a>), )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.OneVsRestQuantifier.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#ordinal_quantification.decomposition.OneVsRestQuantifier.verbose" title="Permalink to this definition"></a></dt>
<dd><p>The verbosity level</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.OneVsRestQuantifier.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_train</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.decomposition.OneVsRestQuantifier.fit" title="Permalink to this definition"></a></dt>
<dd><p>Fits all the quanfifiers of a OneVsRest decomposition</p>
<p>First, the method fits the estimators (estimator_train and estimator_test) (if needed) using
the <cite>fit</cite> method of its superclass</p>
<p>Then, it creates (using <cite>deepcopy</cite>) the set on <a href="#id47"><span class="problematic" id="id48">quantifiers_</span></a>, one per class, and fit them</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>)</em>) – True classes</p></li>
<li><p><strong>predictions_train</strong> (<em>ndarray</em><em>, </em><em>optional</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_classes</em><em>) </em><em>(</em><em>probs</em><em>)</em>) – Predictions of the examples in the training set</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When estimator_train or estimator_test are not instances of OneVsRestClassifier</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.decomposition.OneVsRestQuantifier.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.decomposition.OneVsRestQuantifier.predict" title="Permalink to this definition"></a></dt>
<dd><p>Aggregates the prevalences of the <a href="#id49"><span class="problematic" id="id50">quantifiers_</span></a> to compute the final prediction</p>
<p>Just one aggregation strategy is implemented. It normalizes the prevalences given by each quantifier
to sum 1</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>(</em><em>sparse</em><em>) </em><em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p></li>
<li><p><strong>predictions_test</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_classes</em><em>) </em><em>(</em><em>default=None</em><em>)</em>) – Predictions for the testing bag</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
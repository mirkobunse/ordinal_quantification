<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ordinal_quantification.ordinal package &mdash; ordinal_quantification v0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=57cfd03c"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            ordinal_quantification
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="developer-guide.html">Developer guide</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ordinal_quantification</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">ordinal_quantification.ordinal package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/ordinal_quantification.ordinal.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="ordinal-quantification-ordinal-package">
<h1>ordinal_quantification.ordinal package<a class="headerlink" href="#ordinal-quantification-ordinal-package" title="Permalink to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
</section>
<section id="module-ordinal_quantification.ordinal.ac">
<span id="ordinal-quantification-ordinal-ac-module"></span><h2>ordinal_quantification.ordinal.ac module<a class="headerlink" href="#module-ordinal_quantification.ordinal.ac" title="Permalink to this heading"></a></h2>
<p>Ordinal version of AC quantifier</p>
<dl class="py class">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ac.ACOrdinal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ordinal_quantification.ordinal.ac.</span></span><span class="sig-name descname"><span class="pre">ACOrdinal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator_train</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.ordinal.ac.ACOrdinal" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="ordinal_quantification.html#ordinal_quantification.base.UsingClassifiers" title="ordinal_quantification.base.UsingClassifiers"><code class="xref py py-class docutils literal notranslate"><span class="pre">UsingClassifiers</span></code></a></p>
<p>Adjusted Count method for Ordinal Quantification</p>
<p>The idea is to compute the prevalences that minimizes the EMD distance between cm * prevalences (cm is the
confusion matrix) and the prevalences observed in the testing distribution using the CC method.</p>
<p>This class works in two different ways:</p>
<ol class="arabic simple">
<li><p>Two estimators are used to classify the examples of the training set and the testing set in order to
compute the confusion matrix of both sets. Estimators can be already trained</p></li>
<li><p>You can directly provide the predictions for the examples in the <cite>fit</cite>/<a href="#id1"><span class="problematic" id="id2">`</span></a>predict methods. This is useful
for synthetic/artificial experiments</p></li>
</ol>
<p>The idea in both cases is to guarantee that all methods based on distribution matching are using <strong>exactly</strong>
the same predictions when you compare this kind of quantifiers (and others that also employ an underlying
classifier, for instance, PDFyOrdinal). In the first case, estimators are only trained once and can be shared
for several quantifiers of this kind</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>estimator_train</strong> (<em>estimator object</em><em> (</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and <cite>predict</cite>. It is used to classify the examples of the training
set and to compute the confusion matrix</p></li>
<li><p><strong>estimator_test</strong> (<em>estimator object</em><em> (</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and <cite>predict</cite>. It is used to classify the examples of the testing
set and to obtain their predictions</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=0</em><em>)</em>) – The verbosity level. The default value, zero, means silent mode</p></li>
<li><p><strong>same</strong> (<em>For some experiments both estimators could be the</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ac.ACOrdinal.estimator_train">
<span class="sig-name descname"><span class="pre">estimator_train</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ac.ACOrdinal.estimator_train" title="Permalink to this definition"></a></dt>
<dd><p>Estimator used to classify the examples of the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ac.ACOrdinal.estimator_test">
<span class="sig-name descname"><span class="pre">estimator_test</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ac.ACOrdinal.estimator_test" title="Permalink to this definition"></a></dt>
<dd><p>Estimator used to classify the examples of the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ac.ACOrdinal.predictions_train_">
<span class="sig-name descname"><span class="pre">predictions_train_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ac.ACOrdinal.predictions_train_" title="Permalink to this definition"></a></dt>
<dd><p>Predictions of the examples in the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_examples, ) (crisp estimator)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ac.ACOrdinal.predictions_test_">
<span class="sig-name descname"><span class="pre">predictions_test_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ac.ACOrdinal.predictions_test_" title="Permalink to this definition"></a></dt>
<dd><p>Predictions of the examples in the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_examples, ) (crisp estimator)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ac.ACOrdinal.needs_predictions_train">
<span class="sig-name descname"><span class="pre">needs_predictions_train</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ac.ACOrdinal.needs_predictions_train" title="Permalink to this definition"></a></dt>
<dd><p>It is True because AC quantifiers need to estimate the training distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, True</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ac.ACOrdinal.probabilistic_predictions">
<span class="sig-name descname"><span class="pre">probabilistic_predictions</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ac.ACOrdinal.probabilistic_predictions" title="Permalink to this definition"></a></dt>
<dd><p>This means that <a href="#id13"><span class="problematic" id="id14">predictions_test_</span></a> contains crisp predictions</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, False</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ac.ACOrdinal.classes_">
<span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ac.ACOrdinal.classes_" title="Permalink to this definition"></a></dt>
<dd><p>Class labels</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ac.ACOrdinal.y_ext_">
<span class="sig-name descname"><span class="pre">y_ext_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ac.ACOrdinal.y_ext_" title="Permalink to this definition"></a></dt>
<dd><p>Repmat of true labels of the training set. When CV_estimator is used with averaged_predictions=False,
<a href="#id15"><span class="problematic" id="id16">predictions_train_</span></a> will have a larger dimension (factor=n_repetitions * n_folds of the underlying CV)
than y. In other cases, <a href="#id17"><span class="problematic" id="id18">y_ext_</span></a> == y.
<a href="#id19"><span class="problematic" id="id20">y_ext_</span></a> i used in <cite>fit</cite> method whenever the true labels of the training set are needed, instead of y</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape(len(<a href="#id21"><span class="problematic" id="id22">predictions_train_</span></a>, 1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ac.ACOrdinal.cm_">
<span class="sig-name descname"><span class="pre">cm_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ac.ACOrdinal.cm_" title="Permalink to this definition"></a></dt>
<dd><p>Confusion matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes, n_classes)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ac.ACOrdinal.train_distrib_">
<span class="sig-name descname"><span class="pre">train_distrib_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ac.ACOrdinal.train_distrib_" title="Permalink to this definition"></a></dt>
<dd><p>The cumulative distribution for each class in the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (<a href="#id23"><span class="problematic" id="id24">n_classes_</span></a>, n_classes)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ac.ACOrdinal.test_distrib_">
<span class="sig-name descname"><span class="pre">test_distrib_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ac.ACOrdinal.test_distrib_" title="Permalink to this definition"></a></dt>
<dd><p>The cumulative distribution for the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (<a href="#id25"><span class="problematic" id="id26">n_classes_</span></a>, 1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ac.ACOrdinal.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ac.ACOrdinal.verbose" title="Permalink to this definition"></a></dt>
<dd><p>The verbosity level</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>Notice that at least one between estimator_train/predictions_train and estimator_test/predictions_test
must be not None. If both are None a ValueError exception will be raised. If both are not None,
predictions_train/predictions_test are used</p>
<p class="rubric">References</p>
<p>George Forman. 2008. Quantifying counts and costs via classification. Data Mining Knowledge Discovery 17,
2 (2008), 164–206.</p>
<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ac.ACOrdinal.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_train</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.ordinal.ac.ACOrdinal.fit" title="Permalink to this definition"></a></dt>
<dd><p>This method performs the following operations: 1) fits the estimators for the training set and the
testing set (if needed), and 2) computes <a href="#id27"><span class="problematic" id="id28">predictions_train_</span></a> (crisp values) if needed. Both operations are
performed by the <cite>fit</cite> method of its superclass.
Finally the method computes the confusion matrix of the training set using <a href="#id29"><span class="problematic" id="id30">predictions_train_</span></a>, and
the training distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>)</em>) – True classes</p></li>
<li><p><strong>predictions_train</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>) or </em><em>(</em><em>n_examples</em><em>, </em><em>n_classes</em><em>)</em>) – Predictions of the examples in the training set. If shape is (n_examples, n_classes) predictions are
converted to crisp values by <a href="#id3"><span class="problematic" id="id4">`</span></a>super().fit()</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When estimator_train and predictions_train are both None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ac.ACOrdinal.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.ordinal.ac.ACOrdinal.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict the class distribution of a testing bag</p>
<p>First, <a href="#id31"><span class="problematic" id="id32">predictions_test_</span></a> are computed (if needed, when predictions_test parameter is None) by
<cite>super().predict()</cite> method.</p>
<p>After that, the distribution of such predictions are computed and stored in <a href="#id33"><span class="problematic" id="id34">test_distrib_</span></a> attribute
Finally, the prevalences are computed solving the following optimization problem:</p>
<blockquote>
<div><p>Min   | <a href="#id35"><span class="problematic" id="id36">train_distrib_</span></a> * prevalences -  <a href="#id37"><span class="problematic" id="id38">test_distrib_</span></a> |
s.t.  sum(prevalences) = 1</p>
<blockquote>
<div><p>prevalecences_i &gt;= 0</p>
</div></blockquote>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Testing bag</p></li>
<li><p><strong>predictions_test</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_classes</em><em>) </em><em>(</em><em>default=None</em><em>)</em>) – <p>They must be probabilities (the estimator used must have a <a href="#id5"><span class="problematic" id="id6">`</span></a>predict_proba method)</p>
<p>If predictions_test is not None they are copied on <a href="#id39"><span class="problematic" id="id40">predictions_test_</span></a> and used.
If predictions_test is None, predictions for the testing examples are computed using the <cite>predict</cite>
method of estimator_test (it must be an actual estimator)</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When estimator_test and predictions_test are both None</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prevalences</strong> – Contains the predicted prevalence for each class</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray, shape(n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ac.ACOrdinal.set_fit_request">
<span class="sig-name descname"><span class="pre">set_fit_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_train</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'$UNCHANGED$'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#ordinal_quantification.ordinal.ac.ACOrdinal" title="ordinal_quantification.ordinal.ac.ACOrdinal"><span class="pre">ACOrdinal</span></a></span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ac.ACOrdinal.set_fit_request" title="Permalink to this definition"></a></dt>
<dd><p>Request metadata passed to the <code class="docutils literal notranslate"><span class="pre">fit</span></code> method.</p>
<p>Note that this method is only relevant if
<code class="docutils literal notranslate"><span class="pre">enable_metadata_routing=True</span></code> (see <code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.set_config()</span></code>).
Please see <span class="xref std std-ref">User Guide</span> on how the routing
mechanism works.</p>
<p>The options for each parameter are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: metadata is requested, and passed to <code class="docutils literal notranslate"><span class="pre">fit</span></code> if provided. The request is ignored if metadata is not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>: metadata is not requested and the meta-estimator will not pass it to <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</p></li>
</ul>
<p>The default (<code class="docutils literal notranslate"><span class="pre">sklearn.utils.metadata_routing.UNCHANGED</span></code>) retains the
existing request. This allows you to change the request for some
parameters and not others.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only relevant if this estimator is used as a
sub-estimator of a meta-estimator, e.g. used inside a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code>. Otherwise it has no effect.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>predictions_train</strong> (<em>str</em><em>, </em><em>True</em><em>, </em><em>False</em><em>, or </em><em>None</em><em>,                     </em><em>default=sklearn.utils.metadata_routing.UNCHANGED</em>) – Metadata routing for <code class="docutils literal notranslate"><span class="pre">predictions_train</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – The updated object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ac.ACOrdinal.set_predict_request">
<span class="sig-name descname"><span class="pre">set_predict_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_test</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'$UNCHANGED$'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#ordinal_quantification.ordinal.ac.ACOrdinal" title="ordinal_quantification.ordinal.ac.ACOrdinal"><span class="pre">ACOrdinal</span></a></span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ac.ACOrdinal.set_predict_request" title="Permalink to this definition"></a></dt>
<dd><p>Request metadata passed to the <code class="docutils literal notranslate"><span class="pre">predict</span></code> method.</p>
<p>Note that this method is only relevant if
<code class="docutils literal notranslate"><span class="pre">enable_metadata_routing=True</span></code> (see <code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.set_config()</span></code>).
Please see <span class="xref std std-ref">User Guide</span> on how the routing
mechanism works.</p>
<p>The options for each parameter are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: metadata is requested, and passed to <code class="docutils literal notranslate"><span class="pre">predict</span></code> if provided. The request is ignored if metadata is not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>: metadata is not requested and the meta-estimator will not pass it to <code class="docutils literal notranslate"><span class="pre">predict</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</p></li>
</ul>
<p>The default (<code class="docutils literal notranslate"><span class="pre">sklearn.utils.metadata_routing.UNCHANGED</span></code>) retains the
existing request. This allows you to change the request for some
parameters and not others.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only relevant if this estimator is used as a
sub-estimator of a meta-estimator, e.g. used inside a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code>. Otherwise it has no effect.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>predictions_test</strong> (<em>str</em><em>, </em><em>True</em><em>, </em><em>False</em><em>, or </em><em>None</em><em>,                     </em><em>default=sklearn.utils.metadata_routing.UNCHANGED</em>) – Metadata routing for <code class="docutils literal notranslate"><span class="pre">predictions_test</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">predict</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – The updated object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-ordinal_quantification.ordinal.pdf">
<span id="ordinal-quantification-ordinal-pdf-module"></span><h2>ordinal_quantification.ordinal.pdf module<a class="headerlink" href="#module-ordinal_quantification.ordinal.pdf" title="Permalink to this heading"></a></h2>
<p>Ordinal versions for quantifiers based on representing the distributions using PDFs</p>
<dl class="py class">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ordinal_quantification.ordinal.pdf.</span></span><span class="sig-name descname"><span class="pre">PDFOrdinaly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator_train</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L2'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full_probabilistic'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="ordinal_quantification.html#ordinal_quantification.base.UsingClassifiers" title="ordinal_quantification.base.UsingClassifiers"><code class="xref py py-class docutils literal notranslate"><span class="pre">UsingClassifiers</span></code></a></p>
<p>Generic Ordinal version of PDFy method</p>
<p>The idea is to represent the mixture of the training distribution and the testing distribution using PDFs of
the predictions given by a classifier (y). The difference between both is minimized using a distance/loss
function. Originally, (González et al. 2013) propose the Hellinger Distance, but any other distance/loss
function could be used, like L1 or L2. The class has a parameter to select the distance used.</p>
<p>This class (as all classes based on distribution matching using classifiers) works in two different ways:</p>
<ol class="arabic simple">
<li><p>Two estimators are used to classify training examples and testing examples in order to
compute the distribution of both sets. Estimators can be already trained</p></li>
<li><p>You can directly provide the predictions for the examples in the fit/predict methods. This is useful
for synthetic/artificial experiments</p></li>
</ol>
<p>The goal in both cases is to guarantee that all methods based on distribution matching are using <strong>exactly</strong>
the same predictions when you compare this kind of quantifiers. In the first case, estimators are only
trained once and can be shared for several quantifiers of this kind</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>estimator_train</strong> (<em>estimator object</em><em> (</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and <cite>predict_proba</cite>. It is used to classify the examples of the
training set and to compute the distribution of each class individually</p></li>
<li><p><strong>estimator_test</strong> (<em>estimator object</em><em> (</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and <cite>predict_proba</cite>. It is used to classify the examples of the
testing set and to compute the distribution of the whole testing set</p></li>
<li><p><strong>n_bins</strong> (<em>int</em>) – Number of bins to compute the PDFs</p></li>
<li><p><strong>distance</strong> (<em>str</em><em>, </em><em>representing the distance function</em><em> (</em><em>default='HD'</em><em>)</em>) – It is the name of the distance used to compute the difference between the mixture of the training
distribution and the testing distribution</p></li>
<li><p><strong>method</strong> (<em>str</em>) – <p>‘full_probabilistic’ predictions for training and testing set contain a probability for each class
‘winner_node’ this method is only applicable for DDAGClassifier, and predictions contain just the</p>
<blockquote>
<div><p>probabilities for the two consecutive classes of the winner node previous to the leaves</p>
</div></blockquote>
</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>(</em><em>default=1e-05</em><em>)</em>) – The precision of the solution when search is used to compute the prevalence</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=0</em><em>)</em>) – The verbosity level. The default value, zero, means silent mode</p></li>
<li><p><strong>same</strong> (<em>For some experiments both estimator_train and estimator_test could be the</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.estimator_train">
<span class="sig-name descname"><span class="pre">estimator_train</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.estimator_train" title="Permalink to this definition"></a></dt>
<dd><p>Estimator used to classify the examples of the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.estimator_test">
<span class="sig-name descname"><span class="pre">estimator_test</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.estimator_test" title="Permalink to this definition"></a></dt>
<dd><p>Estimator used to classify the examples of the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.predictions_train_">
<span class="sig-name descname"><span class="pre">predictions_train_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.predictions_train_" title="Permalink to this definition"></a></dt>
<dd><p>Predictions of the examples in the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_examples, n_classes) (probabilities)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.predictions_test_">
<span class="sig-name descname"><span class="pre">predictions_test_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.predictions_test_" title="Permalink to this definition"></a></dt>
<dd><p>Predictions of the examples in the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_examples, n_classes) (probabilities)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.needs_predictions_train">
<span class="sig-name descname"><span class="pre">needs_predictions_train</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.needs_predictions_train" title="Permalink to this definition"></a></dt>
<dd><p>It is True because PDFy quantifiers need to estimate the training distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, True</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.probabilistic_predictions">
<span class="sig-name descname"><span class="pre">probabilistic_predictions</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.probabilistic_predictions" title="Permalink to this definition"></a></dt>
<dd><p>This means that <a href="#id41"><span class="problematic" id="id42">predictions_train_</span></a>/<a href="#id43"><span class="problematic" id="id44">predictions_test_</span></a> contain probabilistic predictions</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, True</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.distance" title="Permalink to this definition"></a></dt>
<dd><p>A string with the name of the distance function (‘HD’/’L1’/’L2’) or a distance function</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str or a distance function</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.tol">
<span class="sig-name descname"><span class="pre">tol</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.tol" title="Permalink to this definition"></a></dt>
<dd><p>The precision of the solution when search is used to compute the solution</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.classes_">
<span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.classes_" title="Permalink to this definition"></a></dt>
<dd><p>Class labels</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.y_ext_">
<span class="sig-name descname"><span class="pre">y_ext_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.y_ext_" title="Permalink to this definition"></a></dt>
<dd><p>Repmat of true labels of the training set. When CV_estimator is used with averaged_predictions=False,
<a href="#id45"><span class="problematic" id="id46">predictions_train_</span></a> will have a larger dimension (factor=n_repetitions * n_folds of the underlying CV)
than y. In other cases, <a href="#id47"><span class="problematic" id="id48">y_ext_</span></a> == y.
<a href="#id49"><span class="problematic" id="id50">y_ext_</span></a> i used in <cite>fit</cite> method whenever the true labels of the training set are needed, instead of y</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape(len(<a href="#id51"><span class="problematic" id="id52">predictions_train_</span></a>, 1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.n_bins">
<span class="sig-name descname"><span class="pre">n_bins</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.n_bins" title="Permalink to this definition"></a></dt>
<dd><p>The number of bins to compute the PDFs</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int (default=8)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.train_distrib_">
<span class="sig-name descname"><span class="pre">train_distrib_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.train_distrib_" title="Permalink to this definition"></a></dt>
<dd><p>The PDF for each class in the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_bins * 1, n_classes) binary or (n_bins * <a href="#id53"><span class="problematic" id="id54">n_classes_</span></a>, n_classes) multiclass</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.test_distrib_">
<span class="sig-name descname"><span class="pre">test_distrib_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.test_distrib_" title="Permalink to this definition"></a></dt>
<dd><p>The PDF for the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_bins * 1, 1) binary quantification or (n_bins * <a href="#id55"><span class="problematic" id="id56">n_classes_</span></a>, 1) multiclass</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">G_,</span> <span class="pre">C_,</span> <span class="pre">b_</span></span></dt>
<dd><p>These variables are precomputed in the <cite>fit</cite> method and are used for solving the optimization problem
using <cite>quadprog.solve_qp</cite>. See <cite>compute_l2_param_train</cite> function</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>variables of different kind for defining the optimization problem</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.verbose" title="Permalink to this definition"></a></dt>
<dd><p>The verbosity level</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>Notice that at least one between estimator_train/predictions_train and estimator_test/predictions_test
must be not None. If both are None a ValueError exception will be raised. If both are not None,
predictions_train/predictions_test are used</p>
<p class="rubric">References</p>
<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_train</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.fit" title="Permalink to this definition"></a></dt>
<dd><p>This method performs the following operations: 1) fits the estimators for the training set and the
testing set (if needed), and 2) computes <a href="#id57"><span class="problematic" id="id58">predictions_train_</span></a> (probabilities) if needed. Both operations are
performed by the <cite>fit</cite> method of its superclass.
After that, the method computes the pdfs for all the classes in the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>)</em>) – True classes</p></li>
<li><p><strong>predictions_train</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_classes</em><em>)</em>) – Predictions of the examples in the training set</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When estimator_train and predictions_train are both None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict the class distribution of a testing bag</p>
<p>First, <a href="#id59"><span class="problematic" id="id60">predictions_test_</span></a> are computed (if needed, when predictions_test parameter is None) by
<cite>super().predict()</cite> method.</p>
<p>After that, the method computes the PDF for the testing bag.</p>
<p>Finally, the prevalences are computed using the corresponding function according to the value of
distance attribute</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Testing bag</p></li>
<li><p><strong>predictions_test</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_classes</em><em>) </em><em>(</em><em>default=None</em><em>)</em>) – <p>They must be probabilities (the estimator used must have a <cite>predict_proba</cite> method)</p>
<p>If predictions_test is not None they are copied on <a href="#id61"><span class="problematic" id="id62">predictions_test_</span></a> and used.
If predictions_test is None, predictions for the testing examples are computed using the <cite>predict</cite>
method of estimator_test (it must be an actual estimator)</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When estimator_test and predictions_test are both None</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prevalences</strong> – Contains the predicted prevalence for each class</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray, shape(n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.set_fit_request">
<span class="sig-name descname"><span class="pre">set_fit_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_train</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'$UNCHANGED$'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly" title="ordinal_quantification.ordinal.pdf.PDFOrdinaly"><span class="pre">PDFOrdinaly</span></a></span></span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.set_fit_request" title="Permalink to this definition"></a></dt>
<dd><p>Request metadata passed to the <code class="docutils literal notranslate"><span class="pre">fit</span></code> method.</p>
<p>Note that this method is only relevant if
<code class="docutils literal notranslate"><span class="pre">enable_metadata_routing=True</span></code> (see <code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.set_config()</span></code>).
Please see <span class="xref std std-ref">User Guide</span> on how the routing
mechanism works.</p>
<p>The options for each parameter are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: metadata is requested, and passed to <code class="docutils literal notranslate"><span class="pre">fit</span></code> if provided. The request is ignored if metadata is not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>: metadata is not requested and the meta-estimator will not pass it to <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</p></li>
</ul>
<p>The default (<code class="docutils literal notranslate"><span class="pre">sklearn.utils.metadata_routing.UNCHANGED</span></code>) retains the
existing request. This allows you to change the request for some
parameters and not others.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only relevant if this estimator is used as a
sub-estimator of a meta-estimator, e.g. used inside a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code>. Otherwise it has no effect.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>predictions_train</strong> (<em>str</em><em>, </em><em>True</em><em>, </em><em>False</em><em>, or </em><em>None</em><em>,                     </em><em>default=sklearn.utils.metadata_routing.UNCHANGED</em>) – Metadata routing for <code class="docutils literal notranslate"><span class="pre">predictions_train</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – The updated object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.pdf.PDFOrdinaly.set_predict_request">
<span class="sig-name descname"><span class="pre">set_predict_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_test</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'$UNCHANGED$'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly" title="ordinal_quantification.ordinal.pdf.PDFOrdinaly"><span class="pre">PDFOrdinaly</span></a></span></span><a class="headerlink" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly.set_predict_request" title="Permalink to this definition"></a></dt>
<dd><p>Request metadata passed to the <code class="docutils literal notranslate"><span class="pre">predict</span></code> method.</p>
<p>Note that this method is only relevant if
<code class="docutils literal notranslate"><span class="pre">enable_metadata_routing=True</span></code> (see <code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.set_config()</span></code>).
Please see <span class="xref std std-ref">User Guide</span> on how the routing
mechanism works.</p>
<p>The options for each parameter are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: metadata is requested, and passed to <code class="docutils literal notranslate"><span class="pre">predict</span></code> if provided. The request is ignored if metadata is not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>: metadata is not requested and the meta-estimator will not pass it to <code class="docutils literal notranslate"><span class="pre">predict</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</p></li>
</ul>
<p>The default (<code class="docutils literal notranslate"><span class="pre">sklearn.utils.metadata_routing.UNCHANGED</span></code>) retains the
existing request. This allows you to change the request for some
parameters and not others.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only relevant if this estimator is used as a
sub-estimator of a meta-estimator, e.g. used inside a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code>. Otherwise it has no effect.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>predictions_test</strong> (<em>str</em><em>, </em><em>True</em><em>, </em><em>False</em><em>, or </em><em>None</em><em>,                     </em><em>default=sklearn.utils.metadata_routing.UNCHANGED</em>) – Metadata routing for <code class="docutils literal notranslate"><span class="pre">predictions_test</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">predict</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – The updated object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-ordinal_quantification.ordinal.trees">
<span id="ordinal-quantification-ordinal-trees-module"></span><h2>ordinal_quantification.ordinal.trees module<a class="headerlink" href="#module-ordinal_quantification.ordinal.trees" title="Permalink to this heading"></a></h2>
<p>Ordinal quantification trees</p>
<dl class="py class">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.trees.OrdinalQuantificationTree">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ordinal_quantification.ordinal.trees.</span></span><span class="sig-name descname"><span class="pre">OrdinalQuantificationTree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.ordinal.trees.OrdinalQuantificationTree" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="ordinal_quantification.classify_and_count.html#ordinal_quantification.classify_and_count.cc.PCC" title="ordinal_quantification.classify_and_count.cc.PCC"><code class="xref py py-class docutils literal notranslate"><span class="pre">PCC</span></code></a></p>
<p>Ordinal Quantification Trees proposed by (Martino, Gao and Sebastiani, 2016)</p>
<p>This class is just a wrapper. It is a PCC method in which the estimator for the test distribution is a
FrankAndHallTreeClassifier. Notice that the estimator object for the OrdinalQuantificationTree must be
the binary base estimator used by the FrankAndHallTreeClassifier</p>
<p>Instead of using this class, our recommedation is to employ directly a PCC object to improve the efficiency
because the FrankAndHallTreeClassifier estimator can be shared with other quantifiers and trained just once.</p>
<p class="rubric">References</p>
<p>Giovanni Da San Martino, Wei Gao, and Fabrizio Sebastiani. 2016a. Ordinal text quantification.
In Proceedings of the International ACM SIGIR Conference on  Research and Development
in Information Retrieval. 937940.</p>
<p>Giovanni Da San Martino,Wei Gao, and Fabrizio Sebastiani. 2016b.
QCRI at SemEval-2016 Task 4: Probabilistic methods for binary and ordinal quantification.
In Proceedings of the 10th InternationalWorkshop on Semantic Evaluation (SemEval’16).
Association for Computational Linguistics, A, 5863.</p>
<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.trees.OrdinalQuantificationTree.set_fit_request">
<span class="sig-name descname"><span class="pre">set_fit_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_train</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'$UNCHANGED$'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#ordinal_quantification.ordinal.trees.OrdinalQuantificationTree" title="ordinal_quantification.ordinal.trees.OrdinalQuantificationTree"><span class="pre">OrdinalQuantificationTree</span></a></span></span><a class="headerlink" href="#ordinal_quantification.ordinal.trees.OrdinalQuantificationTree.set_fit_request" title="Permalink to this definition"></a></dt>
<dd><p>Request metadata passed to the <code class="docutils literal notranslate"><span class="pre">fit</span></code> method.</p>
<p>Note that this method is only relevant if
<code class="docutils literal notranslate"><span class="pre">enable_metadata_routing=True</span></code> (see <code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.set_config()</span></code>).
Please see <span class="xref std std-ref">User Guide</span> on how the routing
mechanism works.</p>
<p>The options for each parameter are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: metadata is requested, and passed to <code class="docutils literal notranslate"><span class="pre">fit</span></code> if provided. The request is ignored if metadata is not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>: metadata is not requested and the meta-estimator will not pass it to <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</p></li>
</ul>
<p>The default (<code class="docutils literal notranslate"><span class="pre">sklearn.utils.metadata_routing.UNCHANGED</span></code>) retains the
existing request. This allows you to change the request for some
parameters and not others.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only relevant if this estimator is used as a
sub-estimator of a meta-estimator, e.g. used inside a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code>. Otherwise it has no effect.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>predictions_train</strong> (<em>str</em><em>, </em><em>True</em><em>, </em><em>False</em><em>, or </em><em>None</em><em>,                     </em><em>default=sklearn.utils.metadata_routing.UNCHANGED</em>) – Metadata routing for <code class="docutils literal notranslate"><span class="pre">predictions_train</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – The updated object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.trees.OrdinalQuantificationTree.set_predict_request">
<span class="sig-name descname"><span class="pre">set_predict_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_test</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'$UNCHANGED$'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#ordinal_quantification.ordinal.trees.OrdinalQuantificationTree" title="ordinal_quantification.ordinal.trees.OrdinalQuantificationTree"><span class="pre">OrdinalQuantificationTree</span></a></span></span><a class="headerlink" href="#ordinal_quantification.ordinal.trees.OrdinalQuantificationTree.set_predict_request" title="Permalink to this definition"></a></dt>
<dd><p>Request metadata passed to the <code class="docutils literal notranslate"><span class="pre">predict</span></code> method.</p>
<p>Note that this method is only relevant if
<code class="docutils literal notranslate"><span class="pre">enable_metadata_routing=True</span></code> (see <code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.set_config()</span></code>).
Please see <span class="xref std std-ref">User Guide</span> on how the routing
mechanism works.</p>
<p>The options for each parameter are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: metadata is requested, and passed to <code class="docutils literal notranslate"><span class="pre">predict</span></code> if provided. The request is ignored if metadata is not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>: metadata is not requested and the meta-estimator will not pass it to <code class="docutils literal notranslate"><span class="pre">predict</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</p></li>
</ul>
<p>The default (<code class="docutils literal notranslate"><span class="pre">sklearn.utils.metadata_routing.UNCHANGED</span></code>) retains the
existing request. This allows you to change the request for some
parameters and not others.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only relevant if this estimator is used as a
sub-estimator of a meta-estimator, e.g. used inside a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code>. Otherwise it has no effect.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>predictions_test</strong> (<em>str</em><em>, </em><em>True</em><em>, </em><em>False</em><em>, or </em><em>None</em><em>,                     </em><em>default=sklearn.utils.metadata_routing.UNCHANGED</em>) – Metadata routing for <code class="docutils literal notranslate"><span class="pre">predictions_test</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">predict</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – The updated object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-ordinal_quantification.ordinal">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-ordinal_quantification.ordinal" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ACOrdinal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ordinal_quantification.ordinal.</span></span><span class="sig-name descname"><span class="pre">ACOrdinal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator_train</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.ordinal.ACOrdinal" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="ordinal_quantification.html#ordinal_quantification.base.UsingClassifiers" title="ordinal_quantification.base.UsingClassifiers"><code class="xref py py-class docutils literal notranslate"><span class="pre">UsingClassifiers</span></code></a></p>
<p>Adjusted Count method for Ordinal Quantification</p>
<p>The idea is to compute the prevalences that minimizes the EMD distance between cm * prevalences (cm is the
confusion matrix) and the prevalences observed in the testing distribution using the CC method.</p>
<p>This class works in two different ways:</p>
<ol class="arabic simple">
<li><p>Two estimators are used to classify the examples of the training set and the testing set in order to
compute the confusion matrix of both sets. Estimators can be already trained</p></li>
<li><p>You can directly provide the predictions for the examples in the <cite>fit</cite>/<a href="#id7"><span class="problematic" id="id8">`</span></a>predict methods. This is useful
for synthetic/artificial experiments</p></li>
</ol>
<p>The idea in both cases is to guarantee that all methods based on distribution matching are using <strong>exactly</strong>
the same predictions when you compare this kind of quantifiers (and others that also employ an underlying
classifier, for instance, PDFyOrdinal). In the first case, estimators are only trained once and can be shared
for several quantifiers of this kind</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>estimator_train</strong> (<em>estimator object</em><em> (</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and <cite>predict</cite>. It is used to classify the examples of the training
set and to compute the confusion matrix</p></li>
<li><p><strong>estimator_test</strong> (<em>estimator object</em><em> (</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and <cite>predict</cite>. It is used to classify the examples of the testing
set and to obtain their predictions</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=0</em><em>)</em>) – The verbosity level. The default value, zero, means silent mode</p></li>
<li><p><strong>same</strong> (<em>For some experiments both estimators could be the</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ACOrdinal.estimator_train">
<span class="sig-name descname"><span class="pre">estimator_train</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ACOrdinal.estimator_train" title="Permalink to this definition"></a></dt>
<dd><p>Estimator used to classify the examples of the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ACOrdinal.estimator_test">
<span class="sig-name descname"><span class="pre">estimator_test</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ACOrdinal.estimator_test" title="Permalink to this definition"></a></dt>
<dd><p>Estimator used to classify the examples of the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ACOrdinal.predictions_train_">
<span class="sig-name descname"><span class="pre">predictions_train_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ACOrdinal.predictions_train_" title="Permalink to this definition"></a></dt>
<dd><p>Predictions of the examples in the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_examples, ) (crisp estimator)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ACOrdinal.predictions_test_">
<span class="sig-name descname"><span class="pre">predictions_test_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ACOrdinal.predictions_test_" title="Permalink to this definition"></a></dt>
<dd><p>Predictions of the examples in the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_examples, ) (crisp estimator)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ACOrdinal.needs_predictions_train">
<span class="sig-name descname"><span class="pre">needs_predictions_train</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ACOrdinal.needs_predictions_train" title="Permalink to this definition"></a></dt>
<dd><p>It is True because AC quantifiers need to estimate the training distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, True</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ACOrdinal.probabilistic_predictions">
<span class="sig-name descname"><span class="pre">probabilistic_predictions</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ACOrdinal.probabilistic_predictions" title="Permalink to this definition"></a></dt>
<dd><p>This means that <a href="#id63"><span class="problematic" id="id64">predictions_test_</span></a> contains crisp predictions</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, False</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ACOrdinal.classes_">
<span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ACOrdinal.classes_" title="Permalink to this definition"></a></dt>
<dd><p>Class labels</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ACOrdinal.y_ext_">
<span class="sig-name descname"><span class="pre">y_ext_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ACOrdinal.y_ext_" title="Permalink to this definition"></a></dt>
<dd><p>Repmat of true labels of the training set. When CV_estimator is used with averaged_predictions=False,
<a href="#id65"><span class="problematic" id="id66">predictions_train_</span></a> will have a larger dimension (factor=n_repetitions * n_folds of the underlying CV)
than y. In other cases, <a href="#id67"><span class="problematic" id="id68">y_ext_</span></a> == y.
<a href="#id69"><span class="problematic" id="id70">y_ext_</span></a> i used in <cite>fit</cite> method whenever the true labels of the training set are needed, instead of y</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape(len(<a href="#id71"><span class="problematic" id="id72">predictions_train_</span></a>, 1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ACOrdinal.cm_">
<span class="sig-name descname"><span class="pre">cm_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ACOrdinal.cm_" title="Permalink to this definition"></a></dt>
<dd><p>Confusion matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes, n_classes)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ACOrdinal.train_distrib_">
<span class="sig-name descname"><span class="pre">train_distrib_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ACOrdinal.train_distrib_" title="Permalink to this definition"></a></dt>
<dd><p>The cumulative distribution for each class in the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (<a href="#id73"><span class="problematic" id="id74">n_classes_</span></a>, n_classes)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ACOrdinal.test_distrib_">
<span class="sig-name descname"><span class="pre">test_distrib_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ACOrdinal.test_distrib_" title="Permalink to this definition"></a></dt>
<dd><p>The cumulative distribution for the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (<a href="#id75"><span class="problematic" id="id76">n_classes_</span></a>, 1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ACOrdinal.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ACOrdinal.verbose" title="Permalink to this definition"></a></dt>
<dd><p>The verbosity level</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>Notice that at least one between estimator_train/predictions_train and estimator_test/predictions_test
must be not None. If both are None a ValueError exception will be raised. If both are not None,
predictions_train/predictions_test are used</p>
<p class="rubric">References</p>
<p>George Forman. 2008. Quantifying counts and costs via classification. Data Mining Knowledge Discovery 17,
2 (2008), 164–206.</p>
<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ACOrdinal.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_train</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.ordinal.ACOrdinal.fit" title="Permalink to this definition"></a></dt>
<dd><p>This method performs the following operations: 1) fits the estimators for the training set and the
testing set (if needed), and 2) computes <a href="#id77"><span class="problematic" id="id78">predictions_train_</span></a> (crisp values) if needed. Both operations are
performed by the <cite>fit</cite> method of its superclass.
Finally the method computes the confusion matrix of the training set using <a href="#id79"><span class="problematic" id="id80">predictions_train_</span></a>, and
the training distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>)</em>) – True classes</p></li>
<li><p><strong>predictions_train</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>) or </em><em>(</em><em>n_examples</em><em>, </em><em>n_classes</em><em>)</em>) – Predictions of the examples in the training set. If shape is (n_examples, n_classes) predictions are
converted to crisp values by <a href="#id9"><span class="problematic" id="id10">`</span></a>super().fit()</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When estimator_train and predictions_train are both None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ACOrdinal.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.ordinal.ACOrdinal.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict the class distribution of a testing bag</p>
<p>First, <a href="#id81"><span class="problematic" id="id82">predictions_test_</span></a> are computed (if needed, when predictions_test parameter is None) by
<cite>super().predict()</cite> method.</p>
<p>After that, the distribution of such predictions are computed and stored in <a href="#id83"><span class="problematic" id="id84">test_distrib_</span></a> attribute
Finally, the prevalences are computed solving the following optimization problem:</p>
<blockquote>
<div><p>Min   | <a href="#id85"><span class="problematic" id="id86">train_distrib_</span></a> * prevalences -  <a href="#id87"><span class="problematic" id="id88">test_distrib_</span></a> |
s.t.  sum(prevalences) = 1</p>
<blockquote>
<div><p>prevalecences_i &gt;= 0</p>
</div></blockquote>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Testing bag</p></li>
<li><p><strong>predictions_test</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_classes</em><em>) </em><em>(</em><em>default=None</em><em>)</em>) – <p>They must be probabilities (the estimator used must have a <a href="#id11"><span class="problematic" id="id12">`</span></a>predict_proba method)</p>
<p>If predictions_test is not None they are copied on <a href="#id89"><span class="problematic" id="id90">predictions_test_</span></a> and used.
If predictions_test is None, predictions for the testing examples are computed using the <cite>predict</cite>
method of estimator_test (it must be an actual estimator)</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When estimator_test and predictions_test are both None</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prevalences</strong> – Contains the predicted prevalence for each class</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray, shape(n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ACOrdinal.set_fit_request">
<span class="sig-name descname"><span class="pre">set_fit_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_train</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'$UNCHANGED$'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#ordinal_quantification.ordinal.ac.ACOrdinal" title="ordinal_quantification.ordinal.ac.ACOrdinal"><span class="pre">ACOrdinal</span></a></span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ACOrdinal.set_fit_request" title="Permalink to this definition"></a></dt>
<dd><p>Request metadata passed to the <code class="docutils literal notranslate"><span class="pre">fit</span></code> method.</p>
<p>Note that this method is only relevant if
<code class="docutils literal notranslate"><span class="pre">enable_metadata_routing=True</span></code> (see <code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.set_config()</span></code>).
Please see <span class="xref std std-ref">User Guide</span> on how the routing
mechanism works.</p>
<p>The options for each parameter are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: metadata is requested, and passed to <code class="docutils literal notranslate"><span class="pre">fit</span></code> if provided. The request is ignored if metadata is not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>: metadata is not requested and the meta-estimator will not pass it to <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</p></li>
</ul>
<p>The default (<code class="docutils literal notranslate"><span class="pre">sklearn.utils.metadata_routing.UNCHANGED</span></code>) retains the
existing request. This allows you to change the request for some
parameters and not others.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only relevant if this estimator is used as a
sub-estimator of a meta-estimator, e.g. used inside a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code>. Otherwise it has no effect.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>predictions_train</strong> (<em>str</em><em>, </em><em>True</em><em>, </em><em>False</em><em>, or </em><em>None</em><em>,                     </em><em>default=sklearn.utils.metadata_routing.UNCHANGED</em>) – Metadata routing for <code class="docutils literal notranslate"><span class="pre">predictions_train</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – The updated object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.ACOrdinal.set_predict_request">
<span class="sig-name descname"><span class="pre">set_predict_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_test</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'$UNCHANGED$'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#ordinal_quantification.ordinal.ac.ACOrdinal" title="ordinal_quantification.ordinal.ac.ACOrdinal"><span class="pre">ACOrdinal</span></a></span></span><a class="headerlink" href="#ordinal_quantification.ordinal.ACOrdinal.set_predict_request" title="Permalink to this definition"></a></dt>
<dd><p>Request metadata passed to the <code class="docutils literal notranslate"><span class="pre">predict</span></code> method.</p>
<p>Note that this method is only relevant if
<code class="docutils literal notranslate"><span class="pre">enable_metadata_routing=True</span></code> (see <code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.set_config()</span></code>).
Please see <span class="xref std std-ref">User Guide</span> on how the routing
mechanism works.</p>
<p>The options for each parameter are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: metadata is requested, and passed to <code class="docutils literal notranslate"><span class="pre">predict</span></code> if provided. The request is ignored if metadata is not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>: metadata is not requested and the meta-estimator will not pass it to <code class="docutils literal notranslate"><span class="pre">predict</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</p></li>
</ul>
<p>The default (<code class="docutils literal notranslate"><span class="pre">sklearn.utils.metadata_routing.UNCHANGED</span></code>) retains the
existing request. This allows you to change the request for some
parameters and not others.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only relevant if this estimator is used as a
sub-estimator of a meta-estimator, e.g. used inside a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code>. Otherwise it has no effect.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>predictions_test</strong> (<em>str</em><em>, </em><em>True</em><em>, </em><em>False</em><em>, or </em><em>None</em><em>,                     </em><em>default=sklearn.utils.metadata_routing.UNCHANGED</em>) – Metadata routing for <code class="docutils literal notranslate"><span class="pre">predictions_test</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">predict</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – The updated object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.OrdinalQuantificationTree">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ordinal_quantification.ordinal.</span></span><span class="sig-name descname"><span class="pre">OrdinalQuantificationTree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.ordinal.OrdinalQuantificationTree" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="ordinal_quantification.classify_and_count.html#ordinal_quantification.classify_and_count.cc.PCC" title="ordinal_quantification.classify_and_count.cc.PCC"><code class="xref py py-class docutils literal notranslate"><span class="pre">PCC</span></code></a></p>
<p>Ordinal Quantification Trees proposed by (Martino, Gao and Sebastiani, 2016)</p>
<p>This class is just a wrapper. It is a PCC method in which the estimator for the test distribution is a
FrankAndHallTreeClassifier. Notice that the estimator object for the OrdinalQuantificationTree must be
the binary base estimator used by the FrankAndHallTreeClassifier</p>
<p>Instead of using this class, our recommedation is to employ directly a PCC object to improve the efficiency
because the FrankAndHallTreeClassifier estimator can be shared with other quantifiers and trained just once.</p>
<p class="rubric">References</p>
<p>Giovanni Da San Martino, Wei Gao, and Fabrizio Sebastiani. 2016a. Ordinal text quantification.
In Proceedings of the International ACM SIGIR Conference on  Research and Development
in Information Retrieval. 937940.</p>
<p>Giovanni Da San Martino,Wei Gao, and Fabrizio Sebastiani. 2016b.
QCRI at SemEval-2016 Task 4: Probabilistic methods for binary and ordinal quantification.
In Proceedings of the 10th InternationalWorkshop on Semantic Evaluation (SemEval’16).
Association for Computational Linguistics, A, 5863.</p>
<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.OrdinalQuantificationTree.set_fit_request">
<span class="sig-name descname"><span class="pre">set_fit_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_train</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'$UNCHANGED$'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#ordinal_quantification.ordinal.trees.OrdinalQuantificationTree" title="ordinal_quantification.ordinal.trees.OrdinalQuantificationTree"><span class="pre">OrdinalQuantificationTree</span></a></span></span><a class="headerlink" href="#ordinal_quantification.ordinal.OrdinalQuantificationTree.set_fit_request" title="Permalink to this definition"></a></dt>
<dd><p>Request metadata passed to the <code class="docutils literal notranslate"><span class="pre">fit</span></code> method.</p>
<p>Note that this method is only relevant if
<code class="docutils literal notranslate"><span class="pre">enable_metadata_routing=True</span></code> (see <code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.set_config()</span></code>).
Please see <span class="xref std std-ref">User Guide</span> on how the routing
mechanism works.</p>
<p>The options for each parameter are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: metadata is requested, and passed to <code class="docutils literal notranslate"><span class="pre">fit</span></code> if provided. The request is ignored if metadata is not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>: metadata is not requested and the meta-estimator will not pass it to <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</p></li>
</ul>
<p>The default (<code class="docutils literal notranslate"><span class="pre">sklearn.utils.metadata_routing.UNCHANGED</span></code>) retains the
existing request. This allows you to change the request for some
parameters and not others.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only relevant if this estimator is used as a
sub-estimator of a meta-estimator, e.g. used inside a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code>. Otherwise it has no effect.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>predictions_train</strong> (<em>str</em><em>, </em><em>True</em><em>, </em><em>False</em><em>, or </em><em>None</em><em>,                     </em><em>default=sklearn.utils.metadata_routing.UNCHANGED</em>) – Metadata routing for <code class="docutils literal notranslate"><span class="pre">predictions_train</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – The updated object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.OrdinalQuantificationTree.set_predict_request">
<span class="sig-name descname"><span class="pre">set_predict_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_test</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'$UNCHANGED$'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#ordinal_quantification.ordinal.trees.OrdinalQuantificationTree" title="ordinal_quantification.ordinal.trees.OrdinalQuantificationTree"><span class="pre">OrdinalQuantificationTree</span></a></span></span><a class="headerlink" href="#ordinal_quantification.ordinal.OrdinalQuantificationTree.set_predict_request" title="Permalink to this definition"></a></dt>
<dd><p>Request metadata passed to the <code class="docutils literal notranslate"><span class="pre">predict</span></code> method.</p>
<p>Note that this method is only relevant if
<code class="docutils literal notranslate"><span class="pre">enable_metadata_routing=True</span></code> (see <code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.set_config()</span></code>).
Please see <span class="xref std std-ref">User Guide</span> on how the routing
mechanism works.</p>
<p>The options for each parameter are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: metadata is requested, and passed to <code class="docutils literal notranslate"><span class="pre">predict</span></code> if provided. The request is ignored if metadata is not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>: metadata is not requested and the meta-estimator will not pass it to <code class="docutils literal notranslate"><span class="pre">predict</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</p></li>
</ul>
<p>The default (<code class="docutils literal notranslate"><span class="pre">sklearn.utils.metadata_routing.UNCHANGED</span></code>) retains the
existing request. This allows you to change the request for some
parameters and not others.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only relevant if this estimator is used as a
sub-estimator of a meta-estimator, e.g. used inside a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code>. Otherwise it has no effect.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>predictions_test</strong> (<em>str</em><em>, </em><em>True</em><em>, </em><em>False</em><em>, or </em><em>None</em><em>,                     </em><em>default=sklearn.utils.metadata_routing.UNCHANGED</em>) – Metadata routing for <code class="docutils literal notranslate"><span class="pre">predictions_test</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">predict</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – The updated object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">ordinal_quantification.ordinal.</span></span><span class="sig-name descname"><span class="pre">PDFOrdinaly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">estimator_train</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">estimator_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'L2'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'full_probabilistic'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="ordinal_quantification.html#ordinal_quantification.base.UsingClassifiers" title="ordinal_quantification.base.UsingClassifiers"><code class="xref py py-class docutils literal notranslate"><span class="pre">UsingClassifiers</span></code></a></p>
<p>Generic Ordinal version of PDFy method</p>
<p>The idea is to represent the mixture of the training distribution and the testing distribution using PDFs of
the predictions given by a classifier (y). The difference between both is minimized using a distance/loss
function. Originally, (González et al. 2013) propose the Hellinger Distance, but any other distance/loss
function could be used, like L1 or L2. The class has a parameter to select the distance used.</p>
<p>This class (as all classes based on distribution matching using classifiers) works in two different ways:</p>
<ol class="arabic simple">
<li><p>Two estimators are used to classify training examples and testing examples in order to
compute the distribution of both sets. Estimators can be already trained</p></li>
<li><p>You can directly provide the predictions for the examples in the fit/predict methods. This is useful
for synthetic/artificial experiments</p></li>
</ol>
<p>The goal in both cases is to guarantee that all methods based on distribution matching are using <strong>exactly</strong>
the same predictions when you compare this kind of quantifiers. In the first case, estimators are only
trained once and can be shared for several quantifiers of this kind</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>estimator_train</strong> (<em>estimator object</em><em> (</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and <cite>predict_proba</cite>. It is used to classify the examples of the
training set and to compute the distribution of each class individually</p></li>
<li><p><strong>estimator_test</strong> (<em>estimator object</em><em> (</em><em>default=None</em><em>)</em>) – An estimator object implementing <cite>fit</cite> and <cite>predict_proba</cite>. It is used to classify the examples of the
testing set and to compute the distribution of the whole testing set</p></li>
<li><p><strong>n_bins</strong> (<em>int</em>) – Number of bins to compute the PDFs</p></li>
<li><p><strong>distance</strong> (<em>str</em><em>, </em><em>representing the distance function</em><em> (</em><em>default='HD'</em><em>)</em>) – It is the name of the distance used to compute the difference between the mixture of the training
distribution and the testing distribution</p></li>
<li><p><strong>method</strong> (<em>str</em>) – <p>‘full_probabilistic’ predictions for training and testing set contain a probability for each class
‘winner_node’ this method is only applicable for DDAGClassifier, and predictions contain just the</p>
<blockquote>
<div><p>probabilities for the two consecutive classes of the winner node previous to the leaves</p>
</div></blockquote>
</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>(</em><em>default=1e-05</em><em>)</em>) – The precision of the solution when search is used to compute the prevalence</p></li>
<li><p><strong>verbose</strong> (<em>int</em><em>, </em><em>optional</em><em>, </em><em>(</em><em>default=0</em><em>)</em>) – The verbosity level. The default value, zero, means silent mode</p></li>
<li><p><strong>same</strong> (<em>For some experiments both estimator_train and estimator_test could be the</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.estimator_train">
<span class="sig-name descname"><span class="pre">estimator_train</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.estimator_train" title="Permalink to this definition"></a></dt>
<dd><p>Estimator used to classify the examples of the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.estimator_test">
<span class="sig-name descname"><span class="pre">estimator_test</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.estimator_test" title="Permalink to this definition"></a></dt>
<dd><p>Estimator used to classify the examples of the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>estimator</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.predictions_train_">
<span class="sig-name descname"><span class="pre">predictions_train_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.predictions_train_" title="Permalink to this definition"></a></dt>
<dd><p>Predictions of the examples in the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_examples, n_classes) (probabilities)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.predictions_test_">
<span class="sig-name descname"><span class="pre">predictions_test_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.predictions_test_" title="Permalink to this definition"></a></dt>
<dd><p>Predictions of the examples in the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_examples, n_classes) (probabilities)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.needs_predictions_train">
<span class="sig-name descname"><span class="pre">needs_predictions_train</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.needs_predictions_train" title="Permalink to this definition"></a></dt>
<dd><p>It is True because PDFy quantifiers need to estimate the training distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, True</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.probabilistic_predictions">
<span class="sig-name descname"><span class="pre">probabilistic_predictions</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.probabilistic_predictions" title="Permalink to this definition"></a></dt>
<dd><p>This means that <a href="#id91"><span class="problematic" id="id92">predictions_train_</span></a>/<a href="#id93"><span class="problematic" id="id94">predictions_test_</span></a> contain probabilistic predictions</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool, True</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.distance" title="Permalink to this definition"></a></dt>
<dd><p>A string with the name of the distance function (‘HD’/’L1’/’L2’) or a distance function</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str or a distance function</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.tol">
<span class="sig-name descname"><span class="pre">tol</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.tol" title="Permalink to this definition"></a></dt>
<dd><p>The precision of the solution when search is used to compute the solution</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.classes_">
<span class="sig-name descname"><span class="pre">classes_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.classes_" title="Permalink to this definition"></a></dt>
<dd><p>Class labels</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.y_ext_">
<span class="sig-name descname"><span class="pre">y_ext_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.y_ext_" title="Permalink to this definition"></a></dt>
<dd><p>Repmat of true labels of the training set. When CV_estimator is used with averaged_predictions=False,
<a href="#id95"><span class="problematic" id="id96">predictions_train_</span></a> will have a larger dimension (factor=n_repetitions * n_folds of the underlying CV)
than y. In other cases, <a href="#id97"><span class="problematic" id="id98">y_ext_</span></a> == y.
<a href="#id99"><span class="problematic" id="id100">y_ext_</span></a> i used in <cite>fit</cite> method whenever the true labels of the training set are needed, instead of y</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape(len(<a href="#id101"><span class="problematic" id="id102">predictions_train_</span></a>, 1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.n_bins">
<span class="sig-name descname"><span class="pre">n_bins</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.n_bins" title="Permalink to this definition"></a></dt>
<dd><p>The number of bins to compute the PDFs</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int (default=8)</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.train_distrib_">
<span class="sig-name descname"><span class="pre">train_distrib_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.train_distrib_" title="Permalink to this definition"></a></dt>
<dd><p>The PDF for each class in the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_bins * 1, n_classes) binary or (n_bins * <a href="#id103"><span class="problematic" id="id104">n_classes_</span></a>, n_classes) multiclass</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.test_distrib_">
<span class="sig-name descname"><span class="pre">test_distrib_</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.test_distrib_" title="Permalink to this definition"></a></dt>
<dd><p>The PDF for the testing bag</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray, shape (n_bins * 1, 1) binary quantification or (n_bins * <a href="#id105"><span class="problematic" id="id106">n_classes_</span></a>, 1) multiclass</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">G_,</span> <span class="pre">C_,</span> <span class="pre">b_</span></span></dt>
<dd><p>These variables are precomputed in the <cite>fit</cite> method and are used for solving the optimization problem
using <cite>quadprog.solve_qp</cite>. See <cite>compute_l2_param_train</cite> function</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>variables of different kind for defining the optimization problem</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.verbose" title="Permalink to this definition"></a></dt>
<dd><p>The verbosity level</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Notes</p>
<p>Notice that at least one between estimator_train/predictions_train and estimator_test/predictions_test
must be not None. If both are None a ValueError exception will be raised. If both are not None,
predictions_train/predictions_test are used</p>
<p class="rubric">References</p>
<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.fit">
<span class="sig-name descname"><span class="pre">fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_train</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.fit" title="Permalink to this definition"></a></dt>
<dd><p>This method performs the following operations: 1) fits the estimators for the training set and the
testing set (if needed), and 2) computes <a href="#id107"><span class="problematic" id="id108">predictions_train_</span></a> (probabilities) if needed. Both operations are
performed by the <cite>fit</cite> method of its superclass.
After that, the method computes the pdfs for all the classes in the training set</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Data</p></li>
<li><p><strong>y</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>)</em>) – True classes</p></li>
<li><p><strong>predictions_train</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_classes</em><em>)</em>) – Predictions of the examples in the training set</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When estimator_train and predictions_train are both None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.predict">
<span class="sig-name descname"><span class="pre">predict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.predict" title="Permalink to this definition"></a></dt>
<dd><p>Predict the class distribution of a testing bag</p>
<p>First, <a href="#id109"><span class="problematic" id="id110">predictions_test_</span></a> are computed (if needed, when predictions_test parameter is None) by
<cite>super().predict()</cite> method.</p>
<p>After that, the method computes the PDF for the testing bag.</p>
<p>Finally, the prevalences are computed using the corresponding function according to the value of
distance attribute</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_features</em><em>)</em>) – Testing bag</p></li>
<li><p><strong>predictions_test</strong> (<em>ndarray</em><em>, </em><em>shape</em><em> (</em><em>n_examples</em><em>, </em><em>n_classes</em><em>) </em><em>(</em><em>default=None</em><em>)</em>) – <p>They must be probabilities (the estimator used must have a <cite>predict_proba</cite> method)</p>
<p>If predictions_test is not None they are copied on <a href="#id111"><span class="problematic" id="id112">predictions_test_</span></a> and used.
If predictions_test is None, predictions for the testing examples are computed using the <cite>predict</cite>
method of estimator_test (it must be an actual estimator)</p>
</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – When estimator_test and predictions_test are both None</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prevalences</strong> – Contains the predicted prevalence for each class</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray, shape(n_classes, )</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.set_fit_request">
<span class="sig-name descname"><span class="pre">set_fit_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_train</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'$UNCHANGED$'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly" title="ordinal_quantification.ordinal.pdf.PDFOrdinaly"><span class="pre">PDFOrdinaly</span></a></span></span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.set_fit_request" title="Permalink to this definition"></a></dt>
<dd><p>Request metadata passed to the <code class="docutils literal notranslate"><span class="pre">fit</span></code> method.</p>
<p>Note that this method is only relevant if
<code class="docutils literal notranslate"><span class="pre">enable_metadata_routing=True</span></code> (see <code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.set_config()</span></code>).
Please see <span class="xref std std-ref">User Guide</span> on how the routing
mechanism works.</p>
<p>The options for each parameter are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: metadata is requested, and passed to <code class="docutils literal notranslate"><span class="pre">fit</span></code> if provided. The request is ignored if metadata is not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>: metadata is not requested and the meta-estimator will not pass it to <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</p></li>
</ul>
<p>The default (<code class="docutils literal notranslate"><span class="pre">sklearn.utils.metadata_routing.UNCHANGED</span></code>) retains the
existing request. This allows you to change the request for some
parameters and not others.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only relevant if this estimator is used as a
sub-estimator of a meta-estimator, e.g. used inside a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code>. Otherwise it has no effect.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>predictions_train</strong> (<em>str</em><em>, </em><em>True</em><em>, </em><em>False</em><em>, or </em><em>None</em><em>,                     </em><em>default=sklearn.utils.metadata_routing.UNCHANGED</em>) – Metadata routing for <code class="docutils literal notranslate"><span class="pre">predictions_train</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – The updated object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="ordinal_quantification.ordinal.PDFOrdinaly.set_predict_request">
<span class="sig-name descname"><span class="pre">set_predict_request</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predictions_test</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'$UNCHANGED$'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#ordinal_quantification.ordinal.pdf.PDFOrdinaly" title="ordinal_quantification.ordinal.pdf.PDFOrdinaly"><span class="pre">PDFOrdinaly</span></a></span></span><a class="headerlink" href="#ordinal_quantification.ordinal.PDFOrdinaly.set_predict_request" title="Permalink to this definition"></a></dt>
<dd><p>Request metadata passed to the <code class="docutils literal notranslate"><span class="pre">predict</span></code> method.</p>
<p>Note that this method is only relevant if
<code class="docutils literal notranslate"><span class="pre">enable_metadata_routing=True</span></code> (see <code class="xref py py-func docutils literal notranslate"><span class="pre">sklearn.set_config()</span></code>).
Please see <span class="xref std std-ref">User Guide</span> on how the routing
mechanism works.</p>
<p>The options for each parameter are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">True</span></code>: metadata is requested, and passed to <code class="docutils literal notranslate"><span class="pre">predict</span></code> if provided. The request is ignored if metadata is not provided.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">False</span></code>: metadata is not requested and the meta-estimator will not pass it to <code class="docutils literal notranslate"><span class="pre">predict</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: metadata is not requested, and the meta-estimator will raise an error if the user provides it.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">str</span></code>: metadata should be passed to the meta-estimator with this given alias instead of the original name.</p></li>
</ul>
<p>The default (<code class="docutils literal notranslate"><span class="pre">sklearn.utils.metadata_routing.UNCHANGED</span></code>) retains the
existing request. This allows you to change the request for some
parameters and not others.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.3.</span></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is only relevant if this estimator is used as a
sub-estimator of a meta-estimator, e.g. used inside a
<code class="xref py py-class docutils literal notranslate"><span class="pre">Pipeline</span></code>. Otherwise it has no effect.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>predictions_test</strong> (<em>str</em><em>, </em><em>True</em><em>, </em><em>False</em><em>, or </em><em>None</em><em>,                     </em><em>default=sklearn.utils.metadata_routing.UNCHANGED</em>) – Metadata routing for <code class="docutils literal notranslate"><span class="pre">predictions_test</span></code> parameter in <code class="docutils literal notranslate"><span class="pre">predict</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>self</strong> – The updated object.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>